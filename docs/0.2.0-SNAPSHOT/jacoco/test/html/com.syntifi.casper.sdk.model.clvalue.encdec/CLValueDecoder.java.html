<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CLValueDecoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">casper-sdk</a> &gt; <a href="index.source.html" class="el_package">com.syntifi.casper.sdk.model.clvalue.encdec</a> &gt; <span class="el_source">CLValueDecoder.java</span></div><h1>CLValueDecoder.java</h1><pre class="source lang-java linenums">package com.syntifi.casper.sdk.model.clvalue.encdec;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;

import com.syntifi.casper.sdk.exception.BufferEndCLValueDecodeException;
import com.syntifi.casper.sdk.exception.CLValueDecodeException;
import com.syntifi.casper.sdk.exception.InvalidByteStringException;
import com.syntifi.casper.sdk.exception.NoSuchKeyTagException;
import com.syntifi.casper.sdk.model.clvalue.AbstractCLValue;
import com.syntifi.casper.sdk.model.clvalue.CLValueAny;
import com.syntifi.casper.sdk.model.clvalue.CLValueBool;
import com.syntifi.casper.sdk.model.clvalue.CLValueByteArray;
import com.syntifi.casper.sdk.model.clvalue.CLValueI32;
import com.syntifi.casper.sdk.model.clvalue.CLValueI64;
import com.syntifi.casper.sdk.model.clvalue.CLValueKey;
import com.syntifi.casper.sdk.model.clvalue.CLValuePublicKey;
import com.syntifi.casper.sdk.model.clvalue.CLValueString;
import com.syntifi.casper.sdk.model.clvalue.CLValueU128;
import com.syntifi.casper.sdk.model.clvalue.CLValueU256;
import com.syntifi.casper.sdk.model.clvalue.CLValueU32;
import com.syntifi.casper.sdk.model.clvalue.CLValueU512;
import com.syntifi.casper.sdk.model.clvalue.CLValueU64;
import com.syntifi.casper.sdk.model.clvalue.CLValueU8;
import com.syntifi.casper.sdk.model.clvalue.cltype.CLTypeData;
import com.syntifi.casper.sdk.model.key.Key;
import com.syntifi.casper.sdk.model.key.PublicKey;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Casper CLValue Decoding methods
 * 
 * @author Alexandre Carvalho
 * @author Andre Bertolace
 * @see AbstractCLValue
 * @since 0.0.1
 */
public class CLValueDecoder extends ByteArrayInputStream {

<span class="fc" id="L46">    private static final Logger LOGGER = LoggerFactory.getLogger(CLValueDecoder.class);</span>

    private static final String LOG_BUFFER_INIT_MESSAGE_STRING = &quot;Initializing with hexString: {}&quot;;
    private static final String LOG_BUFFER_VALUE_MESSAGE_STRING = &quot;Buffer value: {}&quot;;
    private static final String LOG_DECODED_VALUE_MESSAGE_STRING = &quot;Decoded value for {}: {}&quot;;
    private static final String DECODE_EXCEPTION_BUFFER_END_EMPTY_MESSAGE_STRING = &quot;Buffer empty, could not read data&quot;;
    private static final String DECODE_EXCEPTION_BUFFER_END_MESSAGE_STRING = &quot;Buffer ended, could not read more data&quot;;
    private static final String DECODE_EXCEPTION_WRONG_LENGHT_MESSAGE_STRING = &quot;Could not read %s (Expected length: %d, Actual length: %d)&quot;;
    private static final String DECODE_EXCEPTION_OUT_OF_BOUNDS_MESSAGE_STRING = &quot;Value %s out of bounds for expected type %s&quot;;

    /**
     * Initializes buffer with decoded bytes from hex-encoded {@link String}
     * 
     * @param hexString hex-encoded {@link String} of a CLValue
     * @throws InvalidByteStringException if the byte string is invalid or can't be parsed
     */
    public CLValueDecoder(String hexString) throws InvalidByteStringException {
<span class="fc" id="L63">        super(StringByteHelper.hexStringToByteArray(hexString));</span>

<span class="fc" id="L65">        LOGGER.debug(LOG_BUFFER_INIT_MESSAGE_STRING, hexString);</span>
<span class="fc" id="L66">    }</span>

    /**
     * Boolean values serialize as a single byte; true maps to 1, while false maps
     * to 0.
     * 
     * @param clValue target {@link CLValueBool}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readBool(CLValueBool clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L77">        int length = 1;</span>
<span class="fc" id="L78">        byte[] buf = new byte[length];</span>

<span class="fc" id="L80">        int readBytes = 0;</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L82">            throwReadBytesError(Boolean.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L85">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L87">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (buf[0] == 1) {</span>
<span class="fc" id="L89">            clValue.setValue(true);</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        } else if (buf[0] == 0) {</span>
<span class="fc" id="L91">            clValue.setValue(false);</span>
        } else {
<span class="nc" id="L93">            throw new CLValueDecodeException(</span>
<span class="nc" id="L94">                    String.format(DECODE_EXCEPTION_OUT_OF_BOUNDS_MESSAGE_STRING, buf[0], CLTypeData.BOOL));</span>
        }
<span class="fc" id="L96">    }</span>

    /**
     * Numeric values consisting of 64 bits or less serialize in the two’s
     * complement representation with little-endian byte order, and the appropriate
     * number of bytes for the bit-width.
     * 
     * E.g. 7u8 serializes as 0x07
     * 
     * @param clValue target {@link CLValueU8}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU8(CLValueU8 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L110">        byte u8 = readByte();</span>

<span class="fc" id="L112">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Byte.class.getSimpleName(), u8);</span>

<span class="fc" id="L114">        clValue.setBytes(StringByteHelper.convertBytesToHex(new byte[] { u8 }));</span>
<span class="fc" id="L115">        clValue.setValue(u8);</span>
<span class="fc" id="L116">    }</span>

    /**
     * Reads a byteArrayy into a clvalue
     * 
     * @param clValue target {@link CLValueByteArray}
     * @param length the length of the array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException error with input/output while reading the byte array
     */
    public void readByteArray(CLValueByteArray clValue, int length) throws CLValueDecodeException, IOException {
<span class="fc" id="L127">        byte[] bytes = readBytes(length);</span>

<span class="fc" id="L129">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Byte.class.getSimpleName(), bytes);</span>

<span class="fc" id="L131">        clValue.setBytes(StringByteHelper.convertBytesToHex(bytes));</span>
<span class="fc" id="L132">        clValue.setValue(bytes);</span>
<span class="fc" id="L133">    }</span>

    /**
     * Numeric values consisting of 64 bits or less serialize in the two’s
     * complement representation with little-endian byte order, and the appropriate
     * number of bytes for the bit-width.
     * 
     * E.g. 7u32 serializes as 0x07000000 E.g. 1024u32 serializes as 0x00040000
     * 
     * @param clValue target {@link CLValueI32}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readI32(CLValueI32 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L147">        int length = 4;</span>
<span class="fc" id="L148">        byte[] buf = new byte[length];</span>

<span class="fc" id="L150">        int readBytes = 0;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L152">            throwReadBytesError(Integer.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L155">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L157">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L159">        int integerNumber = 0;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L161">            integerNumber += (buf[i] &amp; 0xFF) &lt;&lt; (8 * i);</span>
        }

<span class="fc" id="L164">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Integer.class.getSimpleName(), integerNumber);</span>
<span class="fc" id="L165">        clValue.setValue(integerNumber);</span>
<span class="fc" id="L166">    }</span>

    /**
     * Reads a {@link Long} value from buffer, representing an Unsigned
     * {@link Integer} (U32)
     * 
     * @param clValue target {@link CLValueU32}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU32(CLValueU32 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L177">        int length = 4;</span>
<span class="fc" id="L178">        byte[] buf = new byte[length];</span>

<span class="fc" id="L180">        int readBytes = 0;</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L182">            throwReadBytesError(Long.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L185">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L187">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L189">        int integerNumber = 0;</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L191">            integerNumber += (buf[i] &amp; 0xFF) &lt;&lt; (8 * i);</span>
        }

<span class="fc" id="L194">        long unsignedInteger = Integer.toUnsignedLong(integerNumber);</span>

<span class="fc" id="L196">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Long.class.getSimpleName(), unsignedInteger);</span>
<span class="fc" id="L197">        clValue.setValue(unsignedInteger);</span>
<span class="fc" id="L198">    }</span>

    /**
     * Numeric values consisting of 64 bits or less serialize in the two’s
     * complement representation with little-endian byte order, and the appropriate
     * number of bytes for the bit-width.
     * 
     * E.g. 7u8 serializes as 0x07 E.g. 7u32 serializes as 0x07000000 E.g. 1024u32
     * serializes as 0x00040000
     * 
     * @param clValue target {@link CLValueI64}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readI64(CLValueI64 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L213">        int length = 8;</span>
<span class="fc" id="L214">        byte[] buf = new byte[length];</span>

<span class="fc" id="L216">        int readBytes = 0;</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L218">            throwReadBytesError(Long.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L221">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L223">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L225">        StringByteHelper.reverse(buf);</span>

<span class="fc" id="L227">        String longStringHex = StringByteHelper.convertBytesToHex(buf);</span>

<span class="fc" id="L229">        Long longNumber = Long.parseLong(longStringHex, 16);</span>

<span class="fc" id="L231">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Long.class.getSimpleName(), longNumber);</span>
<span class="fc" id="L232">        clValue.setValue(longNumber);</span>
<span class="fc" id="L233">    }</span>

    /**
     * Reads a {@link BigInteger} value from buffer, representing an Unsigned
     * {@link Long} (U32)
     * 
     * @param clValue target {@link CLValueU64}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU64(CLValueU64 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L244">        int length = 8;</span>
<span class="fc" id="L245">        byte[] buf = new byte[length];</span>

<span class="fc" id="L247">        int readBytes = 0;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L249">            throwReadBytesError(BigInteger.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L252">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L254">        StringByteHelper.reverse(buf);</span>

<span class="fc" id="L256">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

        BigInteger unsignedLong;
        // Since this is a positive (unsigned) number, we should prefix with a zero
        // byte to parse correctly
<span class="fc" id="L261">        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
<span class="fc" id="L262">            outputStream.write(0);</span>
<span class="fc" id="L263">            outputStream.write(buf);</span>

<span class="fc" id="L265">            unsignedLong = new BigInteger(outputStream.toByteArray());</span>
        }

<span class="fc" id="L268">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, BigInteger.class.getSimpleName(), unsignedLong);</span>

<span class="fc" id="L270">        clValue.setValue(unsignedLong);</span>
<span class="fc" id="L271">    }</span>

    /**
     * Reads U128 from buffer
     * 
     * @param clValue target {@link CLValueU128}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU128(CLValueU128 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L281">        this.readBigInteger(clValue);</span>
<span class="fc" id="L282">    }</span>

    /**
     * Reads U256 from buffer
     * 
     * @param clValue target {@link CLValueU256}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU256(CLValueU256 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L292">        this.readBigInteger(clValue);</span>
<span class="fc" id="L293">    }</span>

    /**
     * Reads U512 from buffer
     * 
     * @param clValue target {@link CLValueU512}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU512(CLValueU512 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L303">        this.readBigInteger(clValue);</span>
<span class="fc" id="L304">    }</span>

    /**
     * Wider numeric values (i.e. U128, U256, U512) serialize as one byte given the
     * length of the next number (in bytes), followed by the two’s complement
     * representation with little-endian byte order. The number of bytes should be
     * chosen as small as possible to represent the given number. This is done to
     * reduce the serialization size when small numbers are represented within a
     * wide data type.
     * 
     * E.g. U512::from(7) serializes as 0x0107 E.g. U512::from(1024) serializes as
     * 0x020004 E.g. U512::from(&quot;123456789101112131415&quot;) serializes as
     * 0x0957ff1ada959f4eb106
     * 
     * @param clValue target {@link AbstractCLValue}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    protected void readBigInteger(AbstractCLValue&lt;BigInteger, ?&gt; clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L323">        byte[] buf = new byte[1];</span>

<span class="fc" id="L325">        int readBytes = 0;</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != 1) {</span>
<span class="fc" id="L327">            throw new CLValueDecodeException(String.format(DECODE_EXCEPTION_WRONG_LENGHT_MESSAGE_STRING,</span>
<span class="fc" id="L328">                    Byte.class.getSimpleName(), 1, readBytes));</span>
        }

<span class="fc" id="L331">        byte lengthOfNextNumber = buf[0];</span>

<span class="fc" id="L333">        LOGGER.debug(&quot;Length of next number: {}&quot;, lengthOfNextNumber);</span>

<span class="fc" id="L335">        buf = new byte[lengthOfNextNumber];</span>

<span class="fc bfc" id="L337" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != lengthOfNextNumber) {</span>
<span class="nc" id="L338">            throwReadBytesError(BigInteger.class.getSimpleName(), lengthOfNextNumber, readBytes);</span>
        }

<span class="fc" id="L341">        clValue.setBytes(StringByteHelper.convertBytesToHex(new byte[] { lengthOfNextNumber })</span>
<span class="fc" id="L342">                + StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L344">        StringByteHelper.reverse(buf);</span>

<span class="fc" id="L346">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L348">        BigInteger bigInt = new BigInteger(StringByteHelper.convertBytesToHex(buf), 16);</span>

<span class="fc" id="L350">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, BigInteger.class.getSimpleName(), bigInt);</span>

<span class="fc" id="L352">        clValue.setValue(bigInt);</span>
<span class="fc" id="L353">    }</span>

    /**
     * Reads a {@link CLValueString} value from buffer
     * 
     * @param clValue target {@link CLValueString}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readString(CLValueString clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L363">        int numberByteLength = 4;</span>
<span class="fc" id="L364">        byte[] bufLength = new byte[numberByteLength];</span>

<span class="fc" id="L366">        int readBytes = 0;</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if ((readBytes = this.read(bufLength)) != numberByteLength) {</span>
<span class="nc" id="L368">            throwReadBytesError(Integer.class.getSimpleName(), numberByteLength, readBytes);</span>
        }

<span class="fc" id="L371">        clValue.setBytes(StringByteHelper.convertBytesToHex(bufLength));</span>

<span class="fc" id="L373">        int length = 0;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        for (int i = 0; i &lt; numberByteLength; i++) {</span>
<span class="fc" id="L375">            length += (bufLength[i] &amp; 0xFF) &lt;&lt; (8 * i);</span>
        }

<span class="fc" id="L378">        LOGGER.debug(&quot;Reading string of length: {}&quot;, length);</span>

<span class="fc" id="L380">        byte[] bufString = new byte[length];</span>

<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        if ((readBytes = this.read(bufString)) != length) {</span>
<span class="nc" id="L383">            throwReadBytesError(String.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L386">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, bufString);</span>

<span class="fc" id="L388">        String string = new String(bufString);</span>

<span class="fc" id="L390">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, String.class.getSimpleName(), string);</span>

<span class="fc" id="L392">        clValue.setBytes(clValue.getBytes() + StringByteHelper.convertBytesToHex(bufString));</span>
<span class="fc" id="L393">        clValue.setValue(string);</span>
<span class="fc" id="L394">    }</span>

    /**
     * Reads a {@link CLValuePublicKey} value from buffer
     * 
     * @param clValue target {@link CLValuePublicKey}
     * @throws NoSuchAlgorithmException the requested algorithm was not found
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException error with input/output while reading the byte array
     */
    public void readPublicKey(CLValuePublicKey clValue) throws NoSuchAlgorithmException, CLValueDecodeException, IOException {
<span class="fc" id="L405">        byte[] key = this.readBytes(buf.length);</span>
<span class="fc" id="L406">        clValue.setBytes(StringByteHelper.convertBytesToHex(key));</span>
<span class="fc" id="L407">        clValue.setValue(PublicKey.fromTaggedHexString(clValue.getBytes()));</span>
<span class="fc" id="L408">    }</span>

    /**
     * Reads a {@link CLValueKey} value from buffer
     * 
     * @param clValue target {@link CLValueKey}
     * @throws NoSuchKeyTagException the requested key tag was not found
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException error with input/output while reading the byte array
     */
    public void readKey(CLValueKey clValue) throws NoSuchKeyTagException, CLValueDecodeException, IOException {
<span class="fc" id="L419">        byte[] key = this.readBytes(buf.length);</span>
<span class="fc" id="L420">        clValue.setBytes(StringByteHelper.convertBytesToHex(key));</span>
<span class="fc" id="L421">        clValue.setValue(Key.fromTaggedHexString(clValue.getBytes()));</span>
<span class="fc" id="L422">    }</span>

    /**
     * Reads all bytes as a generic {@link Object} into a {@link CLValueAny}
     * 
     * @param clValue target {@link CLValueAny}
     * @throws IOException error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readAny(CLValueAny clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L432">        try (ObjectInputStream ois = new ObjectInputStream(this)) {</span>
<span class="fc" id="L433">            Object obj = ois.readObject();</span>
<span class="fc" id="L434">            clValue.setValue(obj);</span>
<span class="nc" id="L435">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L436">            throw new CLValueDecodeException(&quot;Class not found&quot;, e);</span>
<span class="fc" id="L437">        }</span>
<span class="fc" id="L438">    }</span>

    /**
     * Reads a single byte
     * 
     * @return the byte read
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException error with input/output while reading the byte array
     */
    protected byte readByte() throws CLValueDecodeException, IOException {
<span class="fc" id="L448">        return this.readBytes(1)[0];</span>
    }

    /**
     * Reads a specified number of bytes
     * 
     * @param length the number of bytes to read
     * @return bytes read
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException error with input/output while reading the byte array
     */
    protected byte[] readBytes(int length) throws CLValueDecodeException, IOException {
<span class="fc" id="L460">        byte[] buf = new byte[length];</span>

<span class="fc" id="L462">        int readBytes = 0;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L464">            throwReadBytesError(Byte.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L467">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L469">        return buf;</span>
    }

    /**
     * 
     * @param simpleName the object's simple name
     * @param expectedLength the expected length
     * @param readBytesLength the actual read bytes length
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    private void throwReadBytesError(String simpleName, int expectedLength, int readBytesLength) throws CLValueDecodeException {
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (this.buf.length == 0) {</span>
<span class="fc" id="L481">            throw new BufferEndCLValueDecodeException(DECODE_EXCEPTION_BUFFER_END_EMPTY_MESSAGE_STRING);</span>
<span class="pc bpc" id="L482" title="1 of 4 branches missed.">        } else if (this.buf.length &gt; 0 &amp;&amp; readBytesLength == -1) {</span>
<span class="fc" id="L483">            throw new BufferEndCLValueDecodeException(DECODE_EXCEPTION_BUFFER_END_MESSAGE_STRING);</span>
        } else {
<span class="fc" id="L485">            throw new CLValueDecodeException(String.format(DECODE_EXCEPTION_WRONG_LENGHT_MESSAGE_STRING, simpleName,</span>
<span class="fc" id="L486">                    expectedLength, readBytesLength));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>