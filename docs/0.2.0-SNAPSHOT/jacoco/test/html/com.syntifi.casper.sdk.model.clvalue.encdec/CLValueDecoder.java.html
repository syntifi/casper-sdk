<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CLValueDecoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">casper-sdk</a> &gt; <a href="index.source.html" class="el_package">com.syntifi.casper.sdk.model.clvalue.encdec</a> &gt; <span class="el_source">CLValueDecoder.java</span></div><h1>CLValueDecoder.java</h1><pre class="source lang-java linenums">package com.syntifi.casper.sdk.model.clvalue.encdec;

import com.syntifi.casper.sdk.exception.BufferEndCLValueDecodeException;
import com.syntifi.casper.sdk.exception.CLValueDecodeException;
import com.syntifi.casper.sdk.exception.InvalidByteStringException;
import com.syntifi.casper.sdk.exception.NoSuchKeyTagException;
import com.syntifi.casper.sdk.model.clvalue.AbstractCLValue;
import com.syntifi.casper.sdk.model.clvalue.CLValueAny;
import com.syntifi.casper.sdk.model.clvalue.CLValueBool;
import com.syntifi.casper.sdk.model.clvalue.CLValueByteArray;
import com.syntifi.casper.sdk.model.clvalue.CLValueI32;
import com.syntifi.casper.sdk.model.clvalue.CLValueI64;
import com.syntifi.casper.sdk.model.clvalue.CLValueKey;
import com.syntifi.casper.sdk.model.clvalue.CLValuePublicKey;
import com.syntifi.casper.sdk.model.clvalue.CLValueString;
import com.syntifi.casper.sdk.model.clvalue.CLValueU128;
import com.syntifi.casper.sdk.model.clvalue.CLValueU256;
import com.syntifi.casper.sdk.model.clvalue.CLValueU32;
import com.syntifi.casper.sdk.model.clvalue.CLValueU512;
import com.syntifi.casper.sdk.model.clvalue.CLValueU64;
import com.syntifi.casper.sdk.model.clvalue.CLValueU8;
import com.syntifi.casper.sdk.model.clvalue.cltype.CLTypeData;
import com.syntifi.casper.sdk.model.key.Key;
import com.syntifi.casper.sdk.model.key.PublicKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;

/**
 * Casper CLValue Decoding methods
 *
 * @author Alexandre Carvalho
 * @author Andre Bertolace
 * @see AbstractCLValue
 * @since 0.0.1
 */
public class CLValueDecoder extends ByteArrayInputStream {

<span class="fc" id="L45">    private static final Logger LOGGER = LoggerFactory.getLogger(CLValueDecoder.class);</span>

    private static final String LOG_BUFFER_INIT_MESSAGE_STRING = &quot;Initializing with hexString: {}&quot;;
    private static final String LOG_BUFFER_VALUE_MESSAGE_STRING = &quot;Buffer value: {}&quot;;
    private static final String LOG_DECODED_VALUE_MESSAGE_STRING = &quot;Decoded value for {}: {}&quot;;
    private static final String DECODE_EXCEPTION_BUFFER_END_EMPTY_MESSAGE_STRING = &quot;Buffer empty, could not read data&quot;;
    private static final String DECODE_EXCEPTION_BUFFER_END_MESSAGE_STRING = &quot;Buffer ended, could not read more data&quot;;
    private static final String DECODE_EXCEPTION_WRONG_LENGTH_MESSAGE_STRING = &quot;Could not read %s (Expected length: %d, Actual length: %d)&quot;;
    private static final String DECODE_EXCEPTION_OUT_OF_BOUNDS_MESSAGE_STRING = &quot;Value %s out of bounds for expected type %s&quot;;

    /**
     * Initializes buffer with decoded bytes from hex-encoded {@link String}
     *
     * @param hexString hex-encoded {@link String} of a CLValue
     * @throws InvalidByteStringException if the byte string is invalid or can't be parsed
     */
    public CLValueDecoder(String hexString) throws InvalidByteStringException {
<span class="fc" id="L62">        super(StringByteHelper.hexStringToByteArray(hexString));</span>

<span class="fc" id="L64">        LOGGER.debug(LOG_BUFFER_INIT_MESSAGE_STRING, hexString);</span>
<span class="fc" id="L65">    }</span>

    /**
     * Boolean values serialize as a single byte; true maps to 1, while false maps
     * to 0.
     *
     * @param clValue target {@link CLValueBool}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readBool(CLValueBool clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L76">        int length = 1;</span>
<span class="fc" id="L77">        byte[] buf = new byte[length];</span>

        int readBytes;
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L81">            throwReadBytesError(Boolean.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L84">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L86">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (buf[0] == 1) {</span>
<span class="fc" id="L88">            clValue.setValue(true);</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        } else if (buf[0] == 0) {</span>
<span class="fc" id="L90">            clValue.setValue(false);</span>
        } else {
<span class="nc" id="L92">            throw new CLValueDecodeException(</span>
<span class="nc" id="L93">                    String.format(DECODE_EXCEPTION_OUT_OF_BOUNDS_MESSAGE_STRING, buf[0], CLTypeData.BOOL));</span>
        }
<span class="fc" id="L95">    }</span>

    /**
     * Numeric values consisting of 64 bits or fewer serialize in the two’s
     * complement representation with little-endian byte order, and the appropriate
     * number of bytes for the bit-width.
     * &lt;p&gt;
     * E.g. 7u8 serializes as 0x07
     *
     * @param clValue target {@link CLValueU8}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU8(CLValueU8 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L109">        byte u8 = readByte();</span>

<span class="fc" id="L111">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Byte.class.getSimpleName(), u8);</span>

<span class="fc" id="L113">        clValue.setBytes(StringByteHelper.convertBytesToHex(new byte[]{u8}));</span>
<span class="fc" id="L114">        clValue.setValue(u8);</span>
<span class="fc" id="L115">    }</span>

    /**
     * Reads a byteArray into a clvalue
     *
     * @param clValue target {@link CLValueByteArray}
     * @param length  the length of the array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException            error with input/output while reading the byte array
     */
    public void readByteArray(CLValueByteArray clValue, int length) throws CLValueDecodeException, IOException {
<span class="fc" id="L126">        byte[] bytes = readBytes(length);</span>

<span class="fc" id="L128">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Byte.class.getSimpleName(), bytes);</span>

<span class="fc" id="L130">        clValue.setBytes(StringByteHelper.convertBytesToHex(bytes));</span>
<span class="fc" id="L131">        clValue.setValue(bytes);</span>
<span class="fc" id="L132">    }</span>

    /**
     * Numeric values consisting of 64 bits or fewer serialize in the two’s
     * complement representation with little-endian byte order, and the appropriate
     * number of bytes for the bit-width.
     * &lt;p&gt;
     * E.g. 7u32 serializes as 0x07000000 E.g. 1024u32 serializes as 0x00040000
     *
     * @param clValue target {@link CLValueI32}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readI32(CLValueI32 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L146">        int length = 4;</span>
<span class="fc" id="L147">        byte[] buf = new byte[length];</span>

        int readBytes;
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L151">            throwReadBytesError(Integer.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L154">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L156">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L158">        int integerNumber = 0;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L160">            integerNumber += (buf[i] &amp; 0xFF) &lt;&lt; (8 * i);</span>
        }

<span class="fc" id="L163">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Integer.class.getSimpleName(), integerNumber);</span>
<span class="fc" id="L164">        clValue.setValue(integerNumber);</span>
<span class="fc" id="L165">    }</span>

    /**
     * Reads a {@link Long} value from buffer, representing an Unsigned
     * {@link Integer} (U32)
     *
     * @param clValue target {@link CLValueU32}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU32(CLValueU32 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L176">        int length = 4;</span>
<span class="fc" id="L177">        byte[] buf = new byte[length];</span>

        int readBytes;
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L181">            throwReadBytesError(Long.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L184">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L186">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L188">        int integerNumber = 0;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L190">            integerNumber += (buf[i] &amp; 0xFF) &lt;&lt; (8 * i);</span>
        }

<span class="fc" id="L193">        long unsignedInteger = Integer.toUnsignedLong(integerNumber);</span>

<span class="fc" id="L195">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Long.class.getSimpleName(), unsignedInteger);</span>
<span class="fc" id="L196">        clValue.setValue(unsignedInteger);</span>
<span class="fc" id="L197">    }</span>

    /**
     * Numeric values consisting of 64 bits or fewer serialize in the two’s
     * complement representation with little-endian byte order, and the appropriate
     * number of bytes for the bit-width.
     * &lt;p&gt;
     * E.g. 7u8 serializes as 0x07 E.g. 7u32 serializes as 0x07000000 E.g. 1024u32
     * serializes as 0x00040000
     *
     * @param clValue target {@link CLValueI64}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readI64(CLValueI64 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L212">        int length = 8;</span>
<span class="fc" id="L213">        byte[] buf = new byte[length];</span>

        int readBytes;
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L217">            throwReadBytesError(Long.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L220">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L222">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L224">        StringByteHelper.reverse(buf);</span>

<span class="fc" id="L226">        String longStringHex = StringByteHelper.convertBytesToHex(buf);</span>

<span class="fc" id="L228">        Long longNumber = Long.parseLong(longStringHex, 16);</span>

<span class="fc" id="L230">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, Long.class.getSimpleName(), longNumber);</span>
<span class="fc" id="L231">        clValue.setValue(longNumber);</span>
<span class="fc" id="L232">    }</span>

    /**
     * Reads a {@link BigInteger} value from buffer, representing an Unsigned
     * {@link Long} (U32)
     *
     * @param clValue target {@link CLValueU64}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU64(CLValueU64 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L243">        int length = 8;</span>
<span class="fc" id="L244">        byte[] buf = new byte[length];</span>

        int readBytes;
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L248">            throwReadBytesError(BigInteger.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L251">        clValue.setBytes(StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L253">        StringByteHelper.reverse(buf);</span>

<span class="fc" id="L255">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

        BigInteger unsignedLong;
        // Since this is a positive (unsigned) number, we should prefix with a zero
        // byte to parse correctly
<span class="fc" id="L260">        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
<span class="fc" id="L261">            outputStream.write(0);</span>
<span class="fc" id="L262">            outputStream.write(buf);</span>

<span class="fc" id="L264">            unsignedLong = new BigInteger(outputStream.toByteArray());</span>
        }

<span class="fc" id="L267">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, BigInteger.class.getSimpleName(), unsignedLong);</span>

<span class="fc" id="L269">        clValue.setValue(unsignedLong);</span>
<span class="fc" id="L270">    }</span>

    /**
     * Reads U128 from buffer
     *
     * @param clValue target {@link CLValueU128}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU128(CLValueU128 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L280">        this.readBigInteger(clValue);</span>
<span class="fc" id="L281">    }</span>

    /**
     * Reads U256 from buffer
     *
     * @param clValue target {@link CLValueU256}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU256(CLValueU256 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L291">        this.readBigInteger(clValue);</span>
<span class="fc" id="L292">    }</span>

    /**
     * Reads U512 from buffer
     *
     * @param clValue target {@link CLValueU512}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readU512(CLValueU512 clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L302">        this.readBigInteger(clValue);</span>
<span class="fc" id="L303">    }</span>

    /**
     * Wider numeric values (i.e. U128, U256, U512) serialize as one byte given the
     * length of the next number (in bytes), followed by the two’s complement
     * representation with little-endian byte order. The number of bytes should be
     * chosen as small as possible to represent the given number. This is done to
     * reduce the serialization size when small numbers are represented within a
     * wide data type.
     * &lt;p&gt;
     * E.g. U512::from(7) serializes as 0x0107 E.g. U512::from(1024) serializes as
     * 0x020004 E.g. U512::from(&quot;123456789101112131415&quot;) serializes as
     * 0x0957ff1ada959f4eb106
     *
     * @param clValue target {@link AbstractCLValue}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    protected void readBigInteger(AbstractCLValue&lt;BigInteger, ?&gt; clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L322">        byte[] buf = new byte[1];</span>

        int readBytes;
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != 1) {</span>
<span class="fc" id="L326">            throw new CLValueDecodeException(String.format(DECODE_EXCEPTION_WRONG_LENGTH_MESSAGE_STRING,</span>
<span class="fc" id="L327">                    Byte.class.getSimpleName(), 1, readBytes));</span>
        }

<span class="fc" id="L330">        byte lengthOfNextNumber = buf[0];</span>

<span class="fc" id="L332">        LOGGER.debug(&quot;Length of next number: {}&quot;, lengthOfNextNumber);</span>

<span class="fc" id="L334">        buf = new byte[lengthOfNextNumber];</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != lengthOfNextNumber) {</span>
<span class="nc" id="L337">            throwReadBytesError(BigInteger.class.getSimpleName(), lengthOfNextNumber, readBytes);</span>
        }

<span class="fc" id="L340">        clValue.setBytes(StringByteHelper.convertBytesToHex(new byte[]{lengthOfNextNumber})</span>
<span class="fc" id="L341">                + StringByteHelper.convertBytesToHex(buf));</span>

<span class="fc" id="L343">        StringByteHelper.reverse(buf);</span>

<span class="fc" id="L345">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L347">        BigInteger bigInt = new BigInteger(StringByteHelper.convertBytesToHex(buf), 16);</span>

<span class="fc" id="L349">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, BigInteger.class.getSimpleName(), bigInt);</span>

<span class="fc" id="L351">        clValue.setValue(bigInt);</span>
<span class="fc" id="L352">    }</span>

    /**
     * Reads a {@link CLValueString} value from buffer
     *
     * @param clValue target {@link CLValueString}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readString(CLValueString clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L362">        int numberByteLength = 4;</span>
<span class="fc" id="L363">        byte[] bufLength = new byte[numberByteLength];</span>

        int readBytes;
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if ((readBytes = this.read(bufLength)) != numberByteLength) {</span>
<span class="nc" id="L367">            throwReadBytesError(Integer.class.getSimpleName(), numberByteLength, readBytes);</span>
        }

<span class="fc" id="L370">        clValue.setBytes(StringByteHelper.convertBytesToHex(bufLength));</span>

<span class="fc" id="L372">        int length = 0;</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">        for (int i = 0; i &lt; numberByteLength; i++) {</span>
<span class="fc" id="L374">            length += (bufLength[i] &amp; 0xFF) &lt;&lt; (8 * i);</span>
        }

<span class="fc" id="L377">        LOGGER.debug(&quot;Reading string of length: {}&quot;, length);</span>

<span class="fc" id="L379">        byte[] bufString = new byte[length];</span>

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if ((readBytes = this.read(bufString)) != length) {</span>
<span class="nc" id="L382">            throwReadBytesError(String.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L385">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, bufString);</span>

<span class="fc" id="L387">        String string = new String(bufString);</span>

<span class="fc" id="L389">        LOGGER.debug(LOG_DECODED_VALUE_MESSAGE_STRING, String.class.getSimpleName(), string);</span>

<span class="fc" id="L391">        clValue.setBytes(clValue.getBytes() + StringByteHelper.convertBytesToHex(bufString));</span>
<span class="fc" id="L392">        clValue.setValue(string);</span>
<span class="fc" id="L393">    }</span>

    /**
     * Reads a {@link CLValuePublicKey} value from buffer
     *
     * @param clValue target {@link CLValuePublicKey}
     * @throws NoSuchAlgorithmException the requested algorithm was not found
     * @throws CLValueDecodeException   exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException              error with input/output while reading the byte array
     */
    public void readPublicKey(CLValuePublicKey clValue) throws NoSuchAlgorithmException, CLValueDecodeException, IOException {
<span class="fc" id="L404">        byte[] key = this.readBytes(buf.length);</span>
<span class="fc" id="L405">        clValue.setBytes(StringByteHelper.convertBytesToHex(key));</span>
<span class="fc" id="L406">        clValue.setValue(PublicKey.fromTaggedHexString(clValue.getBytes()));</span>
<span class="fc" id="L407">    }</span>

    /**
     * Reads a {@link CLValueKey} value from buffer
     *
     * @param clValue target {@link CLValueKey}
     * @throws NoSuchKeyTagException  the requested key tag was not found
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException            error with input/output while reading the byte array
     */
    public void readKey(CLValueKey clValue) throws NoSuchKeyTagException, CLValueDecodeException, IOException {
<span class="fc" id="L418">        byte[] key = this.readBytes(buf.length);</span>
<span class="fc" id="L419">        clValue.setBytes(StringByteHelper.convertBytesToHex(key));</span>
<span class="fc" id="L420">        clValue.setValue(Key.fromTaggedHexString(clValue.getBytes()));</span>
<span class="fc" id="L421">    }</span>

    /**
     * Reads all bytes as a generic {@link Object} into a {@link CLValueAny}
     *
     * @param clValue target {@link CLValueAny}
     * @throws IOException            error with input/output while reading the byte array
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    public void readAny(CLValueAny clValue) throws IOException, CLValueDecodeException {
<span class="fc" id="L431">        try (ObjectInputStream ois = new ObjectInputStream(this)) {</span>
<span class="fc" id="L432">            Object obj = ois.readObject();</span>
<span class="fc" id="L433">            clValue.setValue(obj);</span>
<span class="nc" id="L434">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L435">            throw new CLValueDecodeException(&quot;Class not found&quot;, e);</span>
<span class="fc" id="L436">        }</span>
<span class="fc" id="L437">    }</span>

    /**
     * Reads a single byte
     *
     * @return the byte read
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException            error with input/output while reading the byte array
     */
    protected byte readByte() throws CLValueDecodeException, IOException {
<span class="fc" id="L447">        return this.readBytes(1)[0];</span>
    }

    /**
     * Reads a specified number of bytes
     *
     * @param length the number of bytes to read
     * @return bytes read
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     * @throws IOException            error with input/output while reading the byte array
     */
    protected byte[] readBytes(int length) throws CLValueDecodeException, IOException {
<span class="fc" id="L459">        byte[] buf = new byte[length];</span>

        int readBytes;
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if ((readBytes = this.read(buf)) != length) {</span>
<span class="nc" id="L463">            throwReadBytesError(Byte.class.getSimpleName(), length, readBytes);</span>
        }

<span class="fc" id="L466">        LOGGER.debug(LOG_BUFFER_VALUE_MESSAGE_STRING, buf);</span>

<span class="fc" id="L468">        return buf;</span>
    }

    /**
     * @param simpleName      the object's simple name
     * @param expectedLength  the expected length
     * @param readBytesLength the actual read bytes length
     * @throws CLValueDecodeException exception holding information of failure to decode a {@link AbstractCLValue}
     */
    private void throwReadBytesError(String simpleName, int expectedLength, int readBytesLength) throws CLValueDecodeException {
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (this.buf.length == 0) {</span>
<span class="fc" id="L479">            throw new BufferEndCLValueDecodeException(DECODE_EXCEPTION_BUFFER_END_EMPTY_MESSAGE_STRING);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        } else if (readBytesLength == -1) {</span>
<span class="fc" id="L481">            throw new BufferEndCLValueDecodeException(DECODE_EXCEPTION_BUFFER_END_MESSAGE_STRING);</span>
        } else {
<span class="fc" id="L483">            throw new CLValueDecodeException(String.format(DECODE_EXCEPTION_WRONG_LENGTH_MESSAGE_STRING, simpleName,</span>
<span class="fc" id="L484">                    expectedLength, readBytesLength));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>